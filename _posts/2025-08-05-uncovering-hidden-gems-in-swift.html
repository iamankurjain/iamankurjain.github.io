---
layout: post
title: "Uncovering Hidden Gems in Swift"
date: 2025-08-25
categories: [iOS, swift]
tags: [programming, swift, iOS]
---

<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Uncovering Hidden Gems in Swift</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Uncovering Hidden Gems in Swift</h1>
</header>
<section data-field="subtitle" class="p-summary">
Discovering Swift’s Hidden Gems. Exploring lesser-known features in Swift.
</section>
<section data-field="body" class="e-content">
<section name="f50c" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="ddae" id="ddae" class="graf graf--h3 graf--leading graf--title">Uncovering Hidden Gems in Swift</h3><figure name="f906" id="f906" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="1*b5uVaR_WMcGf-s3YS09S-Q.png" data-width="1364" data-height="768" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*b5uVaR_WMcGf-s3YS09S-Q.png"></figure><p name="975b" id="975b" class="graf graf--p graf-after--figure">In the world of coding, finding cool stuff hidden in programming languages is like discovering buried treasure. Swift, Apple’s awesome programming language, is full of these hidden gems. It’s famous for being sleek and powerful, but there’s so much more to it! In this article, we’re gonna explore all the cool stuff Swift has to offer. Whether you’re a newbie or a pro coder, there’s something here for everyone. So come along for the ride as we dig deep into Swift and uncover all its awesome features!</p><h3 name="b079" id="b079" class="graf graf--h3 graf-after--p">Labeled Statements</h3><p name="722f" id="722f" class="graf graf--p graf-after--h3">Labeled statements in Swift provide a means to specify a particular loop or conditional block when using control flow statements like <code class="markup--code markup--p-code">break</code> and <code class="markup--code markup--p-code">continue</code>. They are particularly useful when dealing with nested loops or conditions and you need to specify which loop or condition to affect.</p><p name="178d" id="178d" class="graf graf--p graf-after--p">Here’s another example illustrating the use of labeled statements:</p><figure name="66d6" id="66d6" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*xfbHVATMD-N5o9YHh8bhFA.png" data-width="1464" data-height="564" src="https://cdn-images-1.medium.com/max/800/1*xfbHVATMD-N5o9YHh8bhFA.png"></figure><p name="ebc7" id="ebc7" class="graf graf--p graf-after--figure">In this example, we have an outer loop labeled <code class="markup--code markup--p-code">mainLoop</code> and an inner loop labeled <code class="markup--code markup--p-code">subLoop</code>. The <code class="markup--code markup--p-code">break mainLoop</code> statement is used inside the inner loop to break out of the outer loop entirely when the inner loop iteration reaches 2.</p><p name="170a" id="170a" class="graf graf--p graf-after--p">Labeled statements provide a clear and explicit way to manage control flow in complex scenarios, ensuring that the intended loop or condition is affected by the control flow statement. This clarity enhances code readability and maintainability, making it easier for developers to understand and modify code as needed.</p><h3 name="4837" id="4837" class="graf graf--h3 graf-after--p">Variadic Parameters</h3><p name="dd1c" id="dd1c" class="graf graf--p graf-after--h3">Variadic parameters in Swift provide a dynamic and concise way to handle functions that accept a variable number of arguments of the same type. This feature adds versatility to your code, allowing you to create functions that can adapt to different input scenarios effortlessly. By leveraging variadic parameters, you can enhance readability and streamline your code, eliminating the need for explicit array creation and providing a more intuitive syntax for function calls. Moreover, variadic parameters offer a performance advantage for smaller sets of arguments, optimizing the efficiency of your code execution. Overall, embracing variadic parameters empowers you to design more flexible and efficient functions, enriching your Swift programming experience with greater expressiveness and elegance.</p><figure name="38aa" id="38aa" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*RFGL60NQez6zcqmGgZhaLw.png" data-width="1512" data-height="732" src="https://cdn-images-1.medium.com/max/800/1*RFGL60NQez6zcqmGgZhaLw.png"></figure><p name="f7c1" id="f7c1" class="graf graf--p graf-after--figure">In this example, the <code class="markup--code markup--p-code">sum</code> function accepts variadic parameters of type <code class="markup--code markup--p-code">Double</code>. It calculates the total sum of all the numbers passed as arguments. With variadic parameters, we can call the <code class="markup--code markup--p-code">sum</code> function with different numbers of arguments each time. We don&#39;t need to create an array explicitly; instead, we pass individual values directly to the function. This makes the function call more natural and readable, and it adapts seamlessly to different usage scenarios without sacrificing performance or clarity</p><h3 name="4e63" id="4e63" class="graf graf--h3 graf-after--p">Nested Functions</h3><p name="ef5c" id="ef5c" class="graf graf--p graf-after--h3">Nested functions in Swift offer a concise and organized approach to encapsulate functionality within a parent function, promoting modularity and clarity. By defining functions within functions, developers can keep related code together and prevent cluttering the global namespace. Nested functions also have access to variables and constants from their enclosing function’s scope, facilitating clean code design. For example, within a function that calculates the total cost of an order, a nested function could handle tax calculation, ensuring that tax-related logic is neatly contained within the main function:</p><figure name="0ff9" id="0ff9" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*nwp-v8B1c7-D30u1Q62xYA.png" data-width="2104" data-height="854" src="https://cdn-images-1.medium.com/max/800/1*nwp-v8B1c7-D30u1Q62xYA.png"></figure><p name="a622" id="a622" class="graf graf--p graf-after--figure">In this example, the <code class="markup--code markup--p-code">calculateTotalOrderCost</code> function contains a nested function <code class="markup--code markup--p-code">calculateTax</code> responsible for computing the tax amount based on the subtotal. This organization keeps tax-related logic confined within the main function, enhancing code readability and maintainability</p><h3 name="1b48" id="1b48" class="graf graf--h3 graf-after--p">Closures Capturing values</h3><p name="aaa2" id="aaa2" class="graf graf--p graf-after--h3">In Swift, closures provide a powerful way to encapsulate functionality, allowing developers to create reusable units of code that can be passed around and executed at a later time. One intriguing aspect of closures is their ability to capture constants and variables from the surrounding context in which they’re defined. This means that closures can retain references to these values, even if the original scope where they were defined no longer exists. To illustrate this concept, let’s explore a scenario where we create a function factory using closures to generate custom calculator functions. Through this example, we’ll delve into how closures capture values from their enclosing scope, enabling the creation of dynamic and adaptable code structures</p><figure name="fa35" id="fa35" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*HKy98hbOf4LGMzH9rzxZMQ.png" data-width="1616" data-height="1020" src="https://cdn-images-1.medium.com/max/800/1*HKy98hbOf4LGMzH9rzxZMQ.png"></figure><p name="b9e5" id="b9e5" class="graf graf--p graf-after--figure">In this example, the <code class="markup--code markup--p-code">makeCalculator</code> function generates a closure that captures an initial value and applies a specified operation to it. We create two calculators: one for addition and one for multiplication. Each calculator retains its own state (initial value and operation) and produces results accordingly when invoked.</p><h3 name="7ae7" id="7ae7" class="graf graf--h3 graf-after--p">Recursive Enumerations</h3><p name="a78d" id="a78d" class="graf graf--p graf-after--h3">Recursive enumerations in Swift allow you to define enums where associated values can be of the same enum type, enabling the creation of complex, recursive data structures. One classic example of recursive enumeration is representing a binary tree. Let’s see how we can define a binary tree using a recursive enum in Swift:</p><figure name="3cb9" id="3cb9" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*C9zLhOJM7lZJfr0tTuOuJA.png" data-width="660" data-height="315" src="https://cdn-images-1.medium.com/max/800/1*C9zLhOJM7lZJfr0tTuOuJA.png"></figure><p name="cd48" id="cd48" class="graf graf--p graf-after--figure">In this example, we define a recursive enum called <code class="markup--code markup--p-code">BinaryTree</code> that represents a binary tree. The enum has two cases: <code class="markup--code markup--p-code">leaf</code>, which represents an empty leaf node, and <code class="markup--code markup--p-code">node</code>, which represents a node containing a value of type <code class="markup--code markup--p-code">T</code> along with left and right subtrees, both of which are themselves binary trees. The <code class="markup--code markup--p-code">indirect</code> keyword is used to indicate that the <code class="markup--code markup--p-code">node</code> case is recursive.</p><p name="c04e" id="c04e" class="graf graf--p graf-after--p">We then create an example binary tree <code class="markup--code markup--p-code">tree</code> with values <code class="markup--code markup--p-code">1</code>, <code class="markup--code markup--p-code">2</code>, and <code class="markup--code markup--p-code">3</code>, where the root node has two child nodes. This demonstrates how recursive enums allow us to create hierarchical data structures, such as binary trees, in a concise and expressive manner in Swift.</p><h3 name="d2f6" id="d2f6" class="graf graf--h3 graf-after--p">Failable Initializers</h3><p name="6fa9" id="6fa9" class="graf graf--p graf-after--h3">Failable initializers are special initializers defined in classes, structs, and enums that can return <code class="markup--code markup--p-code">nil</code> to indicate failure during initialization. They are denoted by appending a question mark <code class="markup--code markup--p-code">?</code> to the <code class="markup--code markup--p-code">init</code> keyword. They even work with Enumerations with or without raw values.</p><p name="da73" id="da73" class="graf graf--p graf-after--p">Failable initializers are commonly used when initialization cannot always succeed due to invalid input or other conditions. By making an initializer failable, you can handle situations where initialization may fail gracefully, allowing you to communicate the failure to the caller and handle it accordingly.</p><p name="e201" id="e201" class="graf graf--p graf-after--p">Here’s a simple example to illustrate a failable initializer:</p><figure name="f20a" id="f20a" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*jErRM_-7886aSL1H1EID0Q.png" data-width="650" data-height="357" src="https://cdn-images-1.medium.com/max/800/1*jErRM_-7886aSL1H1EID0Q.png"></figure><p name="3a95" id="3a95" class="graf graf--p graf-after--figure">In this example, the <code class="markup--code markup--p-code">Person</code> struct has a failable initializer that takes a <code class="markup--code markup--p-code">name</code> parameter. If the <code class="markup--code markup--p-code">name</code> parameter is empty, the initializer returns <code class="markup--code markup--p-code">nil</code>, indicating failure. Otherwise, it initializes a <code class="markup--code markup--p-code">Person</code> instance with the provided name.</p><p name="ab63" id="ab63" class="graf graf--p graf-after--p">Failable initializers are useful for handling scenarios where initialization may not always be successful, allowing for more robust error handling and code resilience. They provide a way to create instances conditionally based on certain criteria, enhancing the flexibility and safety of your code</p><h3 name="4053" id="4053" class="graf graf--h3 graf-after--p">Managing Conflicts in Swift’s In-Out Parameters</h3><p name="a0f3" id="a0f3" class="graf graf--p graf-after--h3">The concept of in-out parameters is a powerful tool for modifying variables passed to functions. However, there’s a catch when it comes to managing memory access: in-out parameters can lead to conflicts if not handled carefully. Let’s see how Swift deals with overlapping memory access in functions with in-out parameters and propose a solution to avoid conflicts.</p><p name="1d84" id="1d84" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Understanding the Issue</strong>: When a function takes in-out parameters, it gains long-term write access to those variables. This means that the function can modify the variables for the entire duration of its execution. However, this also poses a risk of conflicting memory access, especially if the function modifies global variables or variables accessed elsewhere in the code.</p><p name="3d91" id="3d91" class="graf graf--p graf-after--p">For instance, consider a scenario where a global variable <code class="markup--code markup--p-code">stepSize</code> is being modified within a function <code class="markup--code markup--p-code">increment</code> that takes an in-out parameter <code class="markup--code markup--p-code">number</code>. This could lead to conflicts because both <code class="markup--code markup--p-code">stepSize</code> and <code class="markup--code markup--p-code">number</code> refer to the same memory location.</p><figure name="e445" id="e445" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*PLXdpsyTQB54U-RhvzAynQ.png" data-width="1018" data-height="356" src="https://cdn-images-1.medium.com/max/800/1*PLXdpsyTQB54U-RhvzAynQ.png"></figure><p name="c47e" id="c47e" class="graf graf--p graf-after--figure">In the code above, <code class="markup--code markup--p-code">stepSize</code> is a global variable, and it’s normally accessible from within <code class="markup--code markup--p-code">increment(_:)</code>. However, the read access to <code class="markup--code markup--p-code">stepSize</code> overlaps with the write access to <code class="markup--code markup--p-code">number</code>. As shown in the figure below, both <code class="markup--code markup--p-code">number</code> and <code class="markup--code markup--p-code">stepSize</code> refer to the same location in memory. The read and write accesses refer to the same memory and they overlap, producing a conflict.</p><figure name="bc77" id="bc77" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*JVAgl-GPibYU7cUBWvSe1g.png" data-width="1086" data-height="264" src="https://cdn-images-1.medium.com/max/800/1*JVAgl-GPibYU7cUBWvSe1g.png"></figure><p name="8df3" id="8df3" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">Proposed Solution</strong>: To resolve conflicts arising from overlapping memory access, we can make an explicit copy of the variable before passing it to the function with in-out parameters. By doing so, we ensure that the function operates on a separate copy of the variable, preventing conflicts with the original variable.</p><figure name="7091" id="7091" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*WvL4CdxbRV3lnRu3OBrjcw.png" data-width="1360" data-height="506" src="https://cdn-images-1.medium.com/max/800/1*WvL4CdxbRV3lnRu3OBrjcw.png"></figure><p name="72eb" id="72eb" class="graf graf--p graf-after--figure">Here’s a breakdown of the solution:</p><ol class="postList"><li name="8dfd" id="8dfd" class="graf graf--li graf-after--p">Before calling the function with in-out parameters, create a copy of the variable.</li><li name="c869" id="c869" class="graf graf--li graf-after--li">Pass the copy to the function for modification.</li><li name="87a0" id="87a0" class="graf graf--li graf-after--li">Update the original variable with the modified value obtained from the copy.</li></ol><p name="eea9" id="eea9" class="graf graf--p graf-after--li">By following these steps, we guarantee that there are no conflicting accesses to the same memory location, thus avoiding runtime errors and unexpected behaviour in our code.</p><p name="6d3d" id="6d3d" class="graf graf--p graf-after--p">Managing conflicts in functions with in-out parameters is essential to ensure the stability and reliability of our code. By understanding how Swift handles memory access and employing strategies like making explicit copies of variables, we can effectively mitigate conflicts and write more robust code.</p><h3 name="4178" id="4178" class="graf graf--h3 graf-after--p">Conclusion</h3><p name="9916" id="9916" class="graf graf--p graf-after--h3">So, basically, Swift is not just any old programming language. It’s like a treasure chest full of awesome features waiting to be found. From cool labeled statements to handy failable initializers, Swift has a bunch of stuff that can make coding way easier and more fun.</p><p name="eba5" id="eba5" class="graf graf--p graf-after--p graf--trailing">Once you get the hang of these lesser-known parts of Swift, you’ll be coding like a pro in no time. It’ll help you work faster and make cooler apps. So, don’t be afraid to dive into the unknown with Swift. There’s a whole world of coding awesomeness waiting for you to discover!</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@iamankurjain" class="p-author h-card">Ankur JAIN</a> on <a href="https://medium.com/p/0e785b323dcf"><time class="dt-published" datetime="2024-03-04T13:21:39.451Z">March 4, 2024</time></a>.</p><p><a href="https://medium.com/@iamankurjain/uncovering-hidden-gems-in-swift-0e785b323dcf" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on August 2, 2025.</p></footer></article></body></html>