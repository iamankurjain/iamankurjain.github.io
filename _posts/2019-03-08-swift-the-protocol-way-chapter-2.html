---
layout: post
title: "Swift — The Protocol Way (Chapter 2)"
date: 2019-03-08
categories: [iOS, swift]
tags: [programming, swift, iOS]
---

<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Swift — The Protocol Way — Chapter 2/2</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Swift — The Protocol Way — Chapter 2/2</h1>
</header>
<section data-field="subtitle" class="p-summary">
Introduction
</section>
<section data-field="body" class="e-content">
<section name="fd30" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="03d8" id="03d8" class="graf graf--h3 graf--leading graf--title">Swift — The Protocol Way — Chapter 2/2</h3><h3 name="ac86" id="ac86" class="graf graf--h3 graf-after--h3">Introduction</h3><p name="1e4d" id="1e4d" class="graf graf--p graf-after--h3">We learned the basic usages of Protocols and Delegate pattern in the first chapter. Now Let’s dive into some other topics in Protocols. If you missed Part 1 of this series, I would suggest you go through it <a href="https://medium.com/@ankurjain3771/swift-the-protocol-way-chapter-1-5b8dddea4a09" data-href="https://medium.com/@ankurjain3771/swift-the-protocol-way-chapter-1-5b8dddea4a09" class="markup--anchor markup--p-anchor" target="_blank">Part 1</a></p><h3 name="b016" id="b016" class="graf graf--h3 graf-after--p">Generic Protocols Or Protocols with Associated Type</h3><p name="d7f2" id="d7f2" class="graf graf--p graf-after--h3">So why do we need generic type at first place? Let’s look at this example below</p><pre name="d9c7" id="d9c7" class="graf graf--pre graf-after--p"><em class="markup--em markup--pre-em">//Protocol Associated Types</em><br><strong class="markup--strong markup--pre-strong">enum</strong> AssetType{<br>    <strong class="markup--strong markup--pre-strong">case</strong> Computer<br>    c<strong class="markup--strong markup--pre-strong">ase</strong> Laptop<br>    <strong class="markup--strong markup--pre-strong">case</strong> Mobile<br>    <strong class="markup--strong markup--pre-strong">case</strong> Wifi<br>}</pre><pre name="8268" id="8268" class="graf graf--pre graf-after--pre"><strong class="markup--strong markup--pre-strong">struct</strong> InventoryList&lt;T&gt; {<br>    <strong class="markup--strong markup--pre-strong">var</strong> items: [T]</pre><pre name="09e2" id="09e2" class="graf graf--pre graf-after--pre">    <strong class="markup--strong markup--pre-strong">mutating</strong> <strong class="markup--strong markup--pre-strong">func</strong> add(item: T) {<br>        items.append(item)<br>    }<br>    <strong class="markup--strong markup--pre-strong">mutating</strong> <strong class="markup--strong markup--pre-strong">func</strong> remove() -&gt; T {<br>        <strong class="markup--strong markup--pre-strong">return</strong> items.removeLast()<br>    }</pre><pre name="3b93" id="3b93" class="graf graf--pre graf-after--pre">    <strong class="markup--strong markup--pre-strong">func</strong> isCapacityLow() -&gt; Bool {<br>        <strong class="markup--strong markup--pre-strong">return</strong> items.count &lt; 3<br>    }</pre><pre name="9987" id="9987" class="graf graf--pre graf-after--pre">}</pre><pre name="cca3" id="cca3" class="graf graf--pre graf-after--pre"><strong class="markup--strong markup--pre-strong">var</strong> inventory = InventoryList&lt;AssetType&gt;(items: [AssetType.Computer, AssetType.Mobile,AssetType.Wifi])</pre><p name="4ae5" id="4ae5" class="graf graf--p graf-after--pre">As we can see, with Generics, we can store multiple items to the InventoryList struct. This obviously saves our duplicated code. So how do we take advantage of Generics in Swift? Let’s see</p><p name="47c7" id="47c7" class="graf graf--p graf-after--p">Protocols may define associated type requirements using the associated type keyword:</p><pre name="2976" id="2976" class="graf graf--pre graf-after--p"><em class="markup--em markup--pre-em">//Associated Types</em></pre><pre name="57d1" id="57d1" class="graf graf--pre graf-after--pre"><strong class="markup--strong markup--pre-strong">protocol</strong> CustomCollection {<br>    <strong class="markup--strong markup--pre-strong">associatedtype</strong> CustomType</pre><pre name="8fef" id="8fef" class="graf graf--pre graf-after--pre">    <strong class="markup--strong markup--pre-strong">var</strong> items: [CustomType] { <strong class="markup--strong markup--pre-strong">set</strong> <strong class="markup--strong markup--pre-strong">get</strong> }<br>    <strong class="markup--strong markup--pre-strong">mutating</strong> <strong class="markup--strong markup--pre-strong">func</strong> add(item: CustomType)<br>    <strong class="markup--strong markup--pre-strong">var</strong> size: Int { <strong class="markup--strong markup--pre-strong">get</strong> }<br>    <strong class="markup--strong markup--pre-strong">mutating</strong> <strong class="markup--strong markup--pre-strong">func</strong> removeLast() -&gt; CustomType<br>}</pre><pre name="61bb" id="61bb" class="graf graf--pre graf-after--pre"><strong class="markup--strong markup--pre-strong">extension</strong> CustomCollection{<br>    <strong class="markup--strong markup--pre-strong">mutating</strong> <strong class="markup--strong markup--pre-strong">func</strong> add(item: CustomType) {<br>        items.append(item)<br>    }<br>    <strong class="markup--strong markup--pre-strong">mutating</strong> <strong class="markup--strong markup--pre-strong">func</strong> removeLast() -&gt; CustomType{<br>       <strong class="markup--strong markup--pre-strong">return</strong> items.removeLast()<br>    }<br>}</pre><p name="d923" id="d923" class="graf graf--p graf-after--pre">A type which conforms to the protocol may satisfy an associated type requirement implicitly, by providing a given type where the protocol expects the associated type to appear:</p><blockquote name="c60c" id="c60c" class="graf graf--blockquote graf-after--p"><strong class="markup--strong markup--blockquote-strong"><em class="markup--em markup--blockquote-em">Or in Simple words, we can say that associatedtype creates a hole for a data type which has to be filled by the conforming class or struct!!!!!!!!!!!!!!!!</em></strong></blockquote><p name="5781" id="5781" class="graf graf--p graf-after--blockquote">Let’s see how we conform to Generic Protocols</p><pre name="367a" id="367a" class="graf graf--pre graf-after--p"><strong class="markup--strong markup--pre-strong">struct</strong> StringCollection: CustomCollection{<br>    <strong class="markup--strong markup--pre-strong">typealias</strong> CustomType = String <em class="markup--em markup--pre-em">// Optional</em><br>    <strong class="markup--strong markup--pre-strong">var</strong> items: [String]<br>    <strong class="markup--strong markup--pre-strong">var</strong> size: Int<br>}</pre><p name="4358" id="4358" class="graf graf--p graf-after--pre">CustomType will be considered as String now. It’s that easy!!!</p><h3 name="ceb5" id="ceb5" class="graf graf--h3 graf-after--p">Class Only Protocols</h3><p name="e8df" id="e8df" class="graf graf--p graf-after--h3">A protocol may specify that only a class can implement it through using the class keyword in its inheritance list. This keyword must appear before any other inherited protocols in this list.</p><pre name="90c5" id="90c5" class="graf graf--pre graf-after--p"><strong class="markup--strong markup--pre-strong">protocol</strong> ClassOnlyProtocol: <strong class="markup--strong markup--pre-strong">class</strong>, <strong class="markup--strong markup--pre-strong">CustomCollection</strong> { <br><em class="markup--em markup--pre-em">// Protocol requirements <br>}</em></pre><p name="ecbc" id="ecbc" class="graf graf--p graf-after--pre">If a non-class type tries to implement ClassOnlyProtocol, a compiler error will be generated.</p><pre name="cc9d" id="cc9d" class="graf graf--pre graf-after--p">struct MyStruct: <strong class="markup--strong markup--pre-strong">ClassOnlyProtocol</strong> {<br> // error: Non-class type &#39;MyStruct&#39; cannot conform to class protocol<br> &#39;ClassOnlyProtocol&#39; <br>}</pre><p name="9a79" id="9a79" class="graf graf--p graf-after--pre">Other protocols may inherit from the ClassOnlyProtocol, but they will have the same class-only requirement.</p><pre name="0b3c" id="0b3c" class="graf graf--pre graf-after--p">protocol MyProtocol: <strong class="markup--strong markup--pre-strong">ClassOnlyProtocol</strong> {<br> // ClassOnlyProtocol Requirements <br>// MyProtocol Requirements <br>} <br>class MySecondClass: <strong class="markup--strong markup--pre-strong">MyProtocol</strong> { <br>// ClassOnlyProtocol Requirements <br>// MyProtocol Requirements <br>}</pre><p name="f11f" id="f11f" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">Reference semantics of class-only protocols</strong></p><p name="5b84" id="5b84" class="graf graf--p graf-after--p">Using a class-only protocol allows for reference semantics when the conforming type is unknown</p><pre name="a78e" id="a78e" class="graf graf--pre graf-after--p">protocol <strong class="markup--strong markup--pre-strong">Foo</strong> : <strong class="markup--strong markup--pre-strong">class</strong> {<br> var bar : String { get set } <br>} <br>func <strong class="markup--strong markup--pre-strong">takesAFoo</strong>(<strong class="markup--strong markup--pre-strong">foo:Foo</strong>) { <br>// this assignment requires reference semantics,<br> // as foo is a let constant in this scope. <br>foo.bar = &quot;new value&quot; <br>}</pre><p name="6477" id="6477" class="graf graf--p graf-after--pre">In this example, as Foo is a class-only protocol, the assignment to the bar is valid as the compiler knows that foo is a class type, and therefore has reference semantics.</p><h3 name="1a1b" id="1a1b" class="graf graf--h3 graf-after--p">Protocol extension for a specific conforming class</h3><p name="f9ea" id="f9ea" class="graf graf--p graf-after--h3">You can write the default protocol implementation for a specific class.</p><pre name="5ae9" id="5ae9" class="graf graf--pre graf-after--p"><strong class="markup--strong markup--pre-strong">protocol</strong> MyProtocol {<br>        <strong class="markup--strong markup--pre-strong">func</strong> doSomething()<br>    }<br> <strong class="markup--strong markup--pre-strong">extension</strong> MyProtocol <strong class="markup--strong markup--pre-strong">where</strong> Self: UIViewController {<br>        <strong class="markup--strong markup--pre-strong">func</strong> doSomething() {<br>            print(&quot;UIViewController default protocol implementation&quot;)<br>        }<br>    }</pre><pre name="3baa" id="3baa" class="graf graf--pre graf-after--pre"> <strong class="markup--strong markup--pre-strong">class</strong> MyViewController: UIViewController, MyProtocol { }</pre><pre name="ae17" id="ae17" class="graf graf--pre graf-after--pre"> <strong class="markup--strong markup--pre-strong">let</strong> vc = <strong class="markup--strong markup--pre-strong">MyViewController</strong>()</pre><pre name="73b1" id="73b1" class="graf graf--pre graf-after--pre"> vc.doSomething() <em class="markup--em markup--pre-em">// Prints &quot;UIViewController default protocol <br>implementation&quot;</em></pre><h3 name="55e5" id="55e5" class="graf graf--h3 graf-after--pre">Implementing Hashable protocol</h3><p name="fadf" id="fadf" class="graf graf--p graf-after--h3">Types used in Sets and Dictionaries(key) must conform to Hashable protocol which inherits from Equatable protocol.</p><p name="ae09" id="ae09" class="graf graf--p graf-after--p">Custom type conforming to Hashable protocol must implement</p><ul class="postList"><li name="8767" id="8767" class="graf graf--li graf-after--p">A calculated property hashValue</li><li name="4e12" id="4e12" class="graf graf--li graf-after--li">Define one of the equality operators i.e. == or !=.</li></ul><p name="0443" id="0443" class="graf graf--p graf-after--li">Following example implements Hashable protocol for a custom struct:</p><pre name="9a0a" id="9a0a" class="graf graf--pre graf-after--p"><strong class="markup--strong markup--pre-strong">struct</strong> Cell {<br>        <strong class="markup--strong markup--pre-strong">var</strong> row: Int<br>        <strong class="markup--strong markup--pre-strong">var</strong> col: Int</pre><pre name="f367" id="f367" class="graf graf--pre graf-after--pre">        <strong class="markup--strong markup--pre-strong">init</strong>(<strong class="markup--strong markup--pre-strong">_</strong> row: Int, <strong class="markup--strong markup--pre-strong">_</strong> col: Int) {<br>            <strong class="markup--strong markup--pre-strong">self</strong>.row = row<br>            <strong class="markup--strong markup--pre-strong">self</strong>.col = col<br>        }<br>    }</pre><pre name="6ec7" id="6ec7" class="graf graf--pre graf-after--pre">    <strong class="markup--strong markup--pre-strong">extension</strong> Cell: Hashable {</pre><pre name="46e1" id="46e1" class="graf graf--pre graf-after--pre">        <em class="markup--em markup--pre-em">// Satisfy Hashable requirement</em><br>        <strong class="markup--strong markup--pre-strong">var</strong> hashValue: Int {<br>            <strong class="markup--strong markup--pre-strong">get</strong> {<br>                <strong class="markup--strong markup--pre-strong">return</strong> row.hashValue^col.hashValue<br>            }<br>        }</pre><pre name="fba9" id="fba9" class="graf graf--pre graf-after--pre">        <em class="markup--em markup--pre-em">// Satisfy Equatable requirement</em><br>       <strong class="markup--strong markup--pre-strong">static</strong> <strong class="markup--strong markup--pre-strong">func</strong> ==(lhs: Cell, rhs: Cell) -&gt; Bool {<br>            <strong class="markup--strong markup--pre-strong">return</strong> lhs.col == rhs.col &amp;&amp; lhs.row == rhs.row<br>        }<br>    }</pre><pre name="6c23" id="6c23" class="graf graf--pre graf-after--pre">    <em class="markup--em markup--pre-em">// Now we can make Cell as key of dictonary</em><br>    <strong class="markup--strong markup--pre-strong">var</strong> dict = [Cell : String]()<br>    dict[Cell(0, 0)] = &quot;0, 0&quot;<br>    dict[Cell(1, 0)] = &quot;1, 0&quot;<br>    dict[Cell(0, 1)] = &quot;0, 1&quot;</pre><pre name="ed3a" id="ed3a" class="graf graf--pre graf-after--pre">    <em class="markup--em markup--pre-em">// Also we can create Set of Cells</em><br>    <strong class="markup--strong markup--pre-strong">var</strong> set = Set&lt;Cell&gt;()</pre><pre name="1b30" id="1b30" class="graf graf--pre graf-after--pre">    set.insert(Cell(0, 0))<br>    set.insert(Cell(1, 0))</pre><h3 name="88ba" id="88ba" class="graf graf--h3 graf-after--pre">Conclusion</h3><p name="036f" id="036f" class="graf graf--p graf-after--h3">Apple recommends Protocol Oriented Programming over Object Oriented Programming. So it becomes very important for a Swift developer to make use of the protocols in the best way possible.</p><p name="37e6" id="37e6" class="graf graf--p graf-after--p graf--trailing">See you soon with the next story. B<strong class="markup--strong markup--p-strong">ye</strong>!!</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@iamankurjain" class="p-author h-card">Ankur JAIN</a> on <a href="https://medium.com/p/20fcad41320"><time class="dt-published" datetime="2019-03-08T19:44:03.531Z">March 8, 2019</time></a>.</p><p><a href="https://medium.com/@iamankurjain/swift-the-protocol-way-chapter-2-2-20fcad41320" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on August 2, 2025.</p></footer></article></body></html>