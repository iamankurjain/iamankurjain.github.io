---
layout: post
title: "Swift Async/Await: Conquer Concurrency"
date: 2025-08-04
categories: [iOS, swift]
tags: [programming, swift, iOS, concurrency]
---

<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Swift’s Async/Await: Conquer Concurrency</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Swift’s Async/Await: Conquer Concurrency</h1>
</header>
<section data-field="subtitle" class="p-summary">
Swift has this cool built-in feature that lets you write code that can do multiple things at once, like handling short tasks while also…
</section>
<section data-field="body" class="e-content">
<section name="c1c6" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="26e1" id="26e1" class="graf graf--h3 graf--leading graf--title">Swift’s Async/Await: Conquer Concurrency</h3><figure name="2b76" id="2b76" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="1*Rnl7VUdhR751oSO6yGP--Q.png" data-width="2038" data-height="1384" src="https://cdn-images-1.medium.com/max/800/1*Rnl7VUdhR751oSO6yGP--Q.png"><figcaption class="imageCaption">Concurrency</figcaption></figure><p name="56a1" id="56a1" class="graf graf--p graf-after--figure">Swift has this cool built-in feature that lets you write code that can do multiple things at once, like handling short tasks while also tackling long ones. It’s like a multitasking champ! So When we talk about “concurrency” in this blog, we mean mixing asynchronous and parallel code to do multiple things at once. It’s like juggling tasks in code!</p><p name="4b93" id="4b93" class="graf graf--p graf-after--p">If you’ve dabbled in writing concurrent code before, you might have crossed paths with threads. But here’s the deal in Swift: while it’s built on threads, you don’t have to wrestle with them directly. Swift’s concurrency game is a bit more sophisticated. An async function can kindly step aside from its thread, allowing another async buddy to hop in while the first one is temporarily on hold. And when that first function gets back to work, Swift doesn’t play favorites when it comes to threads — it’s all about sharing the workload!</p><p name="7308" id="7308" class="graf graf--p graf-after--p">You can write concurrent code in Swift without using its special features, but it can get pretty tricky to read and manage. Take this code for instance</p><figure name="2b0d" id="2b0d" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/iamankurjain/0f7cd3a2a86b88bcd3adde88bb2bc7c7.js"></script></figure><p name="9867" id="9867" class="graf graf--p graf-after--figure">In this code, you first have to fetch the user’s location asynchronously. Once you have the location, you need to fetch weather data for that location. Finally, you extract the current temperature from the weather data and display it. Each step requires a completion handler, leading to nested closures. As your code becomes more complex with error handling, additional data processing, or multiple asynchronous calls, the nesting can become unwieldy and challenging to read and maintain.</p><h3 name="178e" id="178e" class="graf graf--h3 graf-after--p">Async/Await</h3><p name="23b1" id="23b1" class="graf graf--p graf-after--h3">An async function or method is like a chill version of regular functions. Unlike the usual ones that finish their job, throw errors, or never come back, async ones can hit pause in the middle if they’re waiting for something. In these async functions, you mark the spots where they can take a break while doing their thing. It’s like giving your code a breather when it needs it!</p><p name="e58f" id="e58f" class="graf graf--p graf-after--p">So, when you want to tell Swift that your function is one of those cool asynchronous ones, you simply throw in the “async” keyword in the function’s declaration, right after listing its parameters. It’s a bit like when you use “throws” to say a function can throw errors. And if your async function gives you something back, just stick “async” before that little arrow thing (-&gt;).</p><p name="c63d" id="c63d" class="graf graf--p graf-after--p">For example, here’s how you might fetch the userLocation:</p><figure name="04ae" id="04ae" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/iamankurjain/11e8358c4c05ac78b752359fef58944a.js"></script></figure><p name="92c3" id="92c3" class="graf graf--p graf-after--figure">When calling an asynchronous method, execution suspends until that method returns. You write <code class="markup--code markup--p-code">await</code> in front of the call to mark the possible suspension point. This is like writing <code class="markup--code markup--p-code">try</code> when calling a throwing function, to mark the possible change to the program’s flow if there’s an error. Inside an asynchronous method, the flow of execution is suspended <em class="markup--em markup--p-em">only </em>when you call another asynchronous method — suspension is never implicit or preemptive — which means every possible suspension point is marked with <code class="markup--code markup--p-code">await</code>.</p><p name="e763" id="e763" class="graf graf--p graf-after--p">For example, the code below fetches userLocation, weather data and current temperature and then displays it:</p><figure name="6400" id="6400" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/iamankurjain/b147c8341d946c2f310b23f1d6f5560f.js"></script></figure><ol class="postList"><li name="168f" id="168f" class="graf graf--li graf-after--figure"><code class="markup--code markup--li-code">let userLocation = await getUserLocation()</code> In this line, we declare a constant variable <code class="markup--code markup--li-code">userLocation</code>. It&#39;s assigned the result of the <code class="markup--code markup--li-code">getLocation()</code> function call, which is marked with <code class="markup--code markup--li-code">await</code>. The <code class="markup--code markup--li-code">await</code> keyword indicates that this is an asynchronous operation, and it will pause execution until the <code class="markup--code markup--li-code">getUserLocation()</code> function completes. It&#39;s similar to saying, &quot;Hey, we&#39;re waiting for the user&#39;s location.&quot;</li><li name="de23" id="de23" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">let weatherData = await getWeatherData(for: userLocation)</code>: Here, we declare another constant variable <code class="markup--code markup--li-code">weatherData</code>. It&#39;s assigned the result of the <code class="markup--code markup--li-code">getWeatherData(for: userLocation)</code> function call. Again, the <code class="markup--code markup--li-code">await</code> keyword is used to signal that this is an asynchronous operation. It means we&#39;re waiting for the weather data based on the user&#39;s location.</li><li name="38a4" id="38a4" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">let temperature = await getCurrentTemperature(from: weatherData)</code>: In this line, we declare a constant variable <code class="markup--code markup--li-code">temperature</code>. It&#39;s assigned the result of the <code class="markup--code markup--li-code">getCurrentTemperature(from: weatherData)</code> function call. Once more, <code class="markup--code markup--li-code">await</code> is used to indicate that this is an asynchronous operation. We&#39;re waiting to get the current temperature from the weather data.</li><li name="b5fd" id="b5fd" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">displayTemperature(temperature)</code>: Finally, we call the <code class="markup--code markup--li-code">displayTemperature()</code> function, passing the <code class="markup--code markup--li-code">temperature</code> as an argument. This line displays the temperature to the user, assuming that <code class="markup--code markup--li-code">temperature</code> now holds the correct value.</li></ol><blockquote name="2d1d" id="2d1d" class="graf graf--blockquote graf-after--li"><em class="markup--em markup--blockquote-em">While the code’s execution is suspended, some other concurrent code in the same program runs. For example, maybe a long-running background task downloading some files. That code also runs until the next suspension point, marked by </em><code class="markup--code markup--blockquote-code"><em class="markup--em markup--blockquote-em">await</em></code><em class="markup--em markup--blockquote-em">, or until it completes.</em></blockquote><p name="ce4d" id="ce4d" class="graf graf--p graf-after--blockquote">The possible suspension points in your code marked with await indicate that the current piece of code might pause execution while waiting for the asynchronous function or method to return. This is also called yielding the thread because, behind the scenes, Swift suspends the execution of your code on the current thread and runs some other code on that thread instead.</p><p name="8d22" id="8d22" class="graf graf--p graf-after--p">But here’s the catch — you can only use <strong class="markup--strong markup--p-strong">await</strong> in specific places in your program:</p><ul class="postList"><li name="eae5" id="eae5" class="graf graf--li graf-after--p">Inside the body of an asynchronous function, method, or property.</li><li name="c8eb" id="c8eb" class="graf graf--li graf-after--li">Inside the static main() method of a structure, class, or enumeration that’s tagged with @main.</li><li name="099e" id="099e" class="graf graf--li graf-after--li">Inside an unstructured child task( Task closure decalred as Task { //Code })</li></ul><h3 name="be58" id="be58" class="graf graf--h3 graf-after--li">Calling Asynchronous Functions in Parallel</h3><p name="d2e1" id="d2e1" class="graf graf--p graf-after--h3">Calling an asynchronous function with <code class="markup--code markup--p-code">await</code> runs only one piece of code at a time. While the asynchronous code is running, the caller waits for that code to finish before moving on to run the next line of code</p><p name="c7dd" id="c7dd" class="graf graf--p graf-after--p">For example to get the list of three different user locations, you could await three calls to the <code class="markup--code markup--p-code">getUserLocation(user: User)</code> function as follows:</p><figure name="01a1" id="01a1" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/iamankurjain/18413556939b89fe169150fdd54df492.js"></script></figure><p name="9c1e" id="9c1e" class="graf graf--p graf-after--figure">This approach has an important drawback: Although the getUserLocation is asynchronous and lets other work happen while it progresses, only one call to getUserLocation<code class="markup--code markup--p-code">(user:)</code> runs at a time. Each user location is fetched before the next one starts fetching. However, there’s no need for these operations to wait — each user location can be fetched independently, or even at the same time.</p><p name="55af" id="55af" class="graf graf--p graf-after--p">To call an asynchronous function and let it run in parallel with code around it, write <code class="markup--code markup--p-code">async</code> in front of <code class="markup--code markup--p-code">let</code> when you define a constant, and then write <code class="markup--code markup--p-code">await</code> each time you use the constant.</p><figure name="2423" id="2423" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/iamankurjain/eab23e2e92f325b7c18ce1ce74140599.js"></script></figure><p name="3a65" id="3a65" class="graf graf--p graf-after--figure">In this example, all three calls to <code class="markup--code markup--p-code">getUserLocation(user:)</code> start without waiting for the previous one to complete. If there are enough system resources available, they can run at the same time. None of these function calls are marked with <code class="markup--code markup--p-code">await</code> because the code doesn’t suspend to wait for the function’s result. Instead, execution continues until the line where <code class="markup--code markup--p-code">locations</code> is defined — at that point, the program needs the results from these asynchronous calls, so you write <code class="markup--code markup--p-code">await</code> to pause execution until all the locations are fetched.</p><p name="d82e" id="d82e" class="graf graf--p graf-after--p">Here’s how you can think about the differences between these two approaches:</p><ul class="postList"><li name="b48d" id="b48d" class="graf graf--li graf-after--p">Call asynchronous functions with <code class="markup--code markup--li-code">await</code> when the code on the following lines depends on that function’s result. This creates work that is carried out sequentially.</li><li name="a36c" id="a36c" class="graf graf--li graf-after--li">Call asynchronous functions with <code class="markup--code markup--li-code">async</code>-<code class="markup--code markup--li-code">let</code> when you don’t need the result until later in your code. This creates work that can be carried out in parallel.</li><li name="2728" id="2728" class="graf graf--li graf-after--li">Both <code class="markup--code markup--li-code">await</code> and <code class="markup--code markup--li-code">async</code>-<code class="markup--code markup--li-code">let</code> allow other code to run while they’re suspended.</li><li name="a358" id="a358" class="graf graf--li graf-after--li">In both cases, you mark the possible suspension point with <code class="markup--code markup--li-code">await</code> to indicate that execution will pause, if needed, until an asynchronous function has returned.</li></ul><p name="57e4" id="57e4" class="graf graf--p graf-after--li">You can also mix both of these approaches in the same code.</p><h3 name="7f58" id="7f58" class="graf graf--h3 graf-after--p">Conclusion</h3><p name="df3d" id="df3d" class="graf graf--p graf-after--h3">In closing, Swift’s async/await concurrency is a game-changer for handling multiple tasks smoothly in your code. It simplifies the process and keeps things organized. It’s like having a trusty sidekick that helps you juggle tasks effortlessly. So, give it a try and make your coding life a lot easier!</p><blockquote name="532c" id="532c" class="graf graf--blockquote graf-after--p"><strong class="markup--strong markup--blockquote-strong">Swift’s async/await, where coding meets concurrency, simplifying the art of multitasking in your programs — one ‘await’ at a time.</strong></blockquote><p name="eeeb" id="eeeb" class="graf graf--p graf-after--blockquote graf--trailing">Thank you for joining me on the async/await exploration in Swift. Happy coding!</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@iamankurjain" class="p-author h-card">Ankur JAIN</a> on <a href="https://medium.com/p/613213db0bdc"><time class="dt-published" datetime="2023-09-25T16:36:59.173Z">September 25, 2023</time></a>.</p><p><a href="https://medium.com/@iamankurjain/swifts-async-await-conquer-concurrency-613213db0bdc" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on August 2, 2025.</p></footer></article></body></html>